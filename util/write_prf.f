	real images(100,18),out(100)
      real MAJFACT, RESTRSH, X0, Y0, MINSLOPE
      character file*20

      integer status,unit,readwrite,blocksize,naxes(2),nfound,bitpix
      integer naxis,pc,gc,varidat,frow,felem
      logical simple,extend

      character*16 ttype(18),tform(18),tunit(18),extname

      data ttype/'INTENS','INT_ERR','GRAD','RAD','RMSRES','FOURSL',
     *     'ITER','NUM','RESID_1','RESID_2','RESID_3','RESID_4',
     *     'ECC','POSANG','X0','Y0','FOUR_2','THIRD_2'/

      data tform/'1E','1E','1E','1E','1E','1E',
     *     '1E','1E','1E','1E','1E','1E',
     *     '1E','1E','1E','1E','1E','1E'/

      data tunit/'','','','','','',
     *     '','','','','','',
     *     '','','','','',''/

      n=iargc()
      call getarg(1,file)
      open(unit=1,file=file)
      line=0
      do
        line=line+1
        read(1,*,end=100) (images(line,i),i=1,18)
      enddo
100   line=line-1
      close(unit=1)

      open(unit=4,file='ellipse.par')
      read(4,*) x0,y0
      read(4,*) ecc
      read(4,*) pa
      read(4,*) MINSLOPE
      read(4,*) MAJFACT
      read(4,*) DMIN
      read(4,*) RMAX
      read(4,*) MINIT
      read(4,*) MAXIT
      read(4,*) DELFACT
      read(4,*) RESTRSH
      read(4,*) UNDWT
      read(4,*) start
      read(4,*) sig
      close(unit=4)

      status=0
      call ftgiou(unit,status)
      call ftopen(unit,'prf.fits',1,blocksize,status)
      if(status.eq.0) then
        call ftdelt(unit,status)
      elseif (status.eq.103) then
        status=0
        call ftcmsg
      else
        status=0
        call ftcmsg
        call ftdelt(unit,status)
      endif
      call ftfiou(unit,status)
      call ftgiou(unit,status)
      call ftinit(unit,'prf.fits',1,status)
      call ftphpr(unit,'T',8,0,0,0,1,'T',status)
      call printerror(status)

      ifields=18
      extname='ELLIPSE_BINARY'
      varidat=0
      call ftcrhd(unit,status)
      call ftphbn(unit,line,ifields,ttype,tform,tunit,
     *            extname,varidat,status)
      call printerror(status)

      call ftpkyf(unit,'X_INT',x0,1,
     *            'Initial X Position (JEDSUB)',status)
      call ftpkyf(unit,'Y_INT',y0,1,
     *            'Initial Y Position (JEDSUB)',status)
      call ftpkyf(unit,'ECC_INT',ecc,3,
     *            'Initial Eccentricity (JEDSUB)',status)
      call ftpkyf(unit,'PA_INT',pa,1,
     *            'Initial Position Angle (JEDSUB)',status)
      call ftpkyf(unit,'MINSLOPE',minslope,1,
     *            'Minimum Profile Slope (JEDSUB)',status)
      call ftpkyf(unit,'MAJFACT',majfact,2,
     *            'Major Axis Factor (JEDSUB)',status)
      call ftpkyf(unit,'DMIN',dmin,1,
     *            'Min Dist for Fitting (JEDSUB)',status)
      call ftpkyf(unit,'RMAX',rmax,1,
     *            'Max Dist for Fitting (JEDSUB)',status)
      call ftpkyj(unit,'MINIT',minit,
     *            'Min Number of Iter (JEDSUB)',status)
      call ftpkyj(unit,'MAXIT',maxit,
     *            'Max Number of Iter (JEDSUB)',status)
      call ftpkyf(unit,'DELFACT',delfact,2,
     *            'Min Fraction of Ellipse (JEDSUB)',status)
      call ftpkyf(unit,'RESTRSH',restrsh,3,
     *            'Max Residual Factor (JEDSUB)',status)
      call ftpkyf(unit,'UNDWT',undwt,1,
     *            'Weight for Undetermined Points (JEDSUB)',status)
      call ftpkyf(unit,'START',start,1,
     *            'Start Radius for Fitting (JEDSUB)',status)
      call ftpkyf(unit,'ERA_SIG',sig,1,
     *            'Erase Sigma (JEDSUB)',status)

      frow=1
      felem=1
      do i=1,18
        do j=1,line
          out(j)=images(j,i)
        enddo
        call ftpcle(unit,i,frow,felem,line,out,status)
      enddo

      print*, 'done'
      call ftclos(unit, status)
      call ftfiou(unit, status)

999	end

      subroutine printerror(status)

C  This subroutine prints out the descriptive text corresponding to the
C  error status value and prints out the contents of the internal
C  error message stack generated by FITSIO whenever an error occurs.

      integer status
      character errtext*30,errmessage*80

C  Check if status is OK (no error); if so, simply return
      if (status .le. 0)return

C  The FTGERR subroutine returns a descriptive 30-character text string that
C  corresponds to the integer error status number.  A complete list of all
C  the error numbers can be found in the back of the FITSIO User's Guide.
      call ftgerr(status,errtext)
      print *,'FITSIO Error Status =',status,': ',errtext

C  FITSIO usually generates an internal stack of error messages whenever
C  an error occurs.  These messages provide much more information on the
C  cause of the problem than can be provided by the single integer error
C  status value.  The FTGMSG subroutine retrieves the oldest message from
C  the stack and shifts any remaining messages on the stack down one
C  position.  FTGMSG is called repeatedly until a blank message is
C  returned, which indicates that the stack is empty.  Each error message
C  may be up to 80 characters in length.  Another subroutine, called
C  FTCMSG, is available to simply clear the whole error message stack in
C  cases where one is not interested in the contents.
      call ftgmsg(errmessage)
      do while (errmessage .ne. ' ')
          print *,errmessage
          call ftgmsg(errmessage)
      end do
      end
C *************************************************************************
      subroutine deletefile(filename,status)

C  A simple little routine to delete a FITS file

      integer status,unit,blocksize
      character*(*) filename

C  Simply return if status is greater than zero
      if (status .gt. 0)return

C  Get an unused Logical Unit Number to use to open the FITS file
      call ftgiou(unit,status)

C  Try to open the file, to see if it exists
      call ftopen(unit,filename,1,blocksize,status)

      if (status .eq. 0)then
C         file was opened;  so now delete it 
          call ftdelt(unit,status)
      else if (status .eq. 103)then
C         file doesn't exist, so just reset status to zero and clear errors
          status=0
          call ftcmsg
      else
C         there was some other error opening the file; delete the file anyway
          status=0
          call ftcmsg
          call ftdelt(unit,status)
      end if

C  Free the unit number for later reuse
      call ftfiou(unit, status)
      end
